import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

serve(async (req) => {
  try {
    if (req.method !== "POST") {
      return new Response("Method Not Allowed", { status: 405 });
    }

    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseAnonKey = Deno.env.get("SUPABASE_ANON_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseAnonKey);

    // ---- Auth (Lovable user session) ----
    const authHeader = req.headers.get("Authorization");
    const { data: authData, error: authError } =
      await supabase.auth.getUser(authHeader ?? "");

    if (authError || !authData?.user) {
      return new Response(JSON.stringify({ error: "Unauthorized" }), {
        status: 401,
      });
    }

    const userId = authData.user.id;

    // ---- Input ----
    const body = await req.json();
    const {
      raw_input,
      project_settings = {},
      run_mode = "single",
      models = ["openai:gpt-5"],
    } = body;

    const sessionId = crypto.randomUUID();
    const comparisonGroupId =
      run_mode === "compare" ? crypto.randomUUID() : null;

    // ---- Stubbed story output (replace later with Python call) ----
    const runs = models.map((modelId: string) => {
      return {
        run_id: crypto.randomUUID(),
        model_id: modelId,
        final_story: {
          title: "Stubbed User Story",
          description:
            "As a user, I want this story to be generated by a real pipeline so that the demo proves end-to-end wiring.",
          acceptance_criteria: [
            "Story is generated via Edge Function",
            "Data is persisted to Supabase",
            "UI renders real backend data",
          ],
        },
        dor: {
          passed: true,
          iterations: 1,
          fail_reasons: [],
        },
        eval: {
          overall: 4.2,
          needs_review: false,
          dimensions: {
            clarity: 4,
            testability: 4,
            domain_correctness: 4,
            completeness: 4,
            scope: 5,
          },
          flags: [],
        },
      };
    });

    // ---- Persist stories ----
    const storyRows = runs.map((r) => ({
      session_id: sessionId,
      comparison_group_id: comparisonGroupId,
      model_id: r.model_id,
      raw_input,
      final_story: r.final_story,
      dor_passed: r.dor.passed,
      dor_iterations: r.dor.iterations,
      dor_fail_reasons: r.dor.fail_reasons,
      created_by: userId,
    }));

    const { data: stories, error: insertError } = await supabase
      .from("sb_stories")
      .insert(storyRows)
      .select();

    if (insertError) {
      throw insertError;
    }

    // ---- Persist evals (stub) ----
    const evalRows = stories!.map((story, idx) => ({
      story_id: story.id,
      eval_profile: "v1",
      overall_score: runs[idx].eval.overall,
      needs_review: runs[idx].eval.needs_review,
      dimension_scores: runs[idx].eval.dimensions,
      flags: runs[idx].eval.flags,
    }));

    await supabase.from("sb_eval_runs").insert(evalRows);

    // ---- Response to UI ----
    return new Response(
      JSON.stringify({
        session_id: sessionId,
        comparison_group_id: comparisonGroupId,
        runs: runs.map((r, idx) => ({
          ...r,
          story_id: stories![idx].id,
        })),
      }),
      { headers: { "Content-Type": "application/json" } }
    );
  } catch (err) {
    console.error(err);
    return new Response(
      JSON.stringify({ error: "Internal Server Error" }),
      { status: 500 }
    );
  }
});
