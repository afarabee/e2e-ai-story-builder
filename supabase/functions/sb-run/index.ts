import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
};

type RunResult = {
  run_id: string;
  model_id: string;
  final_story: {
    title: string;
    description: string;
    acceptance_criteria: string[];
  };
  dor: {
    passed: boolean;
    iterations: number;
    fail_reasons: string[];
  };
  eval: {
    overall: number;
    needs_review: boolean;
    dimensions: Record<string, number>;
    flags: string[];
  };
};

serve(async (req) => {
  const requestId = crypto.randomUUID();
  console.log(`[sb-run] requestId=${requestId}`);

  // CORS preflight
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    if (req.method !== "POST") {
      return new Response("Method Not Allowed", {
        status: 405,
        headers: corsHeaders,
      });
    }

    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseAnonKey = Deno.env.get("SUPABASE_ANON_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseAnonKey);

    // Auth is OPTIONAL for demo mode
    const authHeader = req.headers.get("Authorization") ?? "";
    const { data: authData } = await supabase.auth.getUser(authHeader);
    const userId = authData?.user?.id ?? null;

    const body = await req.json();
    const {
      raw_input,
      project_settings = {},
      run_mode = "single",
      models = ["openai:gpt-5"],
    } = body;

    const sessionId = crypto.randomUUID();
    const comparisonGroupId =
      run_mode === "compare" ? crypto.randomUUID() : null;

    const runs: RunResult[] = (models as string[]).map((modelId: string) => ({
      run_id: crypto.randomUUID(),
      model_id: modelId,
      final_story: {
        title: "Stubbed User Story",
        description:
          "As a user, I want this story to be generated by a real pipeline so that the demo proves end-to-end wiring.",
        acceptance_criteria: [
          "Story is generated via Edge Function",
          "Data is persisted to Supabase",
          "UI renders real backend data",
        ],
      },
      dor: { passed: true, iterations: 1, fail_reasons: [] },
      eval: {
        overall: 4.2,
        needs_review: false,
        dimensions: {
          clarity: 4,
          testability: 4,
          domain_correctness: 4,
          completeness: 4,
          scope: 5,
        },
        flags: [],
      },
    }));

    const storyRows = runs.map((r) => ({
      session_id: sessionId,
      comparison_group_id: comparisonGroupId,
      model_id: r.model_id,
      raw_input,
      final_story: r.final_story,
      dor_passed: r.dor.passed,
      dor_iterations: r.dor.iterations,
      dor_fail_reasons: r.dor.fail_reasons,
      created_by: userId, // null allowed in demo mode
      project_settings,
    }));

    const { data: stories, error: insertError } = await supabase
      .from("sb_stories")
      .insert(storyRows)
      .select();

    if (insertError) throw insertError;

    const evalRows = (stories ?? []).map((story: any, idx: number) => ({
      story_id: story.id,
      eval_profile: "v1",
      overall_score: runs[idx].eval.overall,
      needs_review: runs[idx].eval.needs_review,
      dimension_scores: runs[idx].eval.dimensions,
      flags: runs[idx].eval.flags,
    }));

    // best-effort insert (don't fail the whole request if eval insert has a schema mismatch)
    const { error: evalInsertError } = await supabase
      .from("sb_eval_runs")
      .insert(evalRows);

    if (evalInsertError) {
      console.warn("Eval insert warning:", evalInsertError);
    }

    return new Response(
      JSON.stringify({
        session_id: sessionId,
        comparison_group_id: comparisonGroupId,
        runs: runs.map((r, idx) => ({
          ...r,
          story_id: stories?.[idx]?.id ?? null,
        })),
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  } catch (err) {
    console.error(err);
    return new Response(JSON.stringify({ error: "Internal Server Error" }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
});
